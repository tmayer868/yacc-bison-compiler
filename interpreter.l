/***
 From here and forward the lex files included have the
 sole purpose of interpreting tokens to send forward to
 bison. In the bison files, further work is done with
 defined grammar rules comprised of the tokens and
 their data values returned here.
***/

%{
#include<iostream>
#include <string>
#include "tree.h"
#include "interpreter.tab.h"
#define YY_DECL extern "C" int yylex()
#include<vector>
%}

/***
 Each rule returns a token identifier which is generated by bison
 and is defined in the interpreter.tab.h file. yylval is a union
 of possible data types defined in the bison file. We convert
 the value of the int or string matches and store it within the
 union structure.
***/
%%

[ \t]           ;

"]"            { return EOL; }
"["             { return BOL;}
"END"         { return EOP; }//end of program
"def"           {return DEF;}
"START"         { return BOP;}
"end"           { return END;}
"while"         {return WHILE;}
"if"            {return IF;}
"print"         {return PRINT;}
"max"           {return MAX; }
"roots"         {return ROOTS;}
"high"          {return HIGH;}
"low"           {return LOW;}
"points"        {return POINTS;}
"exp"           {return EXP;}
"log"           {return LOG;}
"pow"           {return POW;}
"cos"           {return COS;}
"sin"           {return SIN;}
"acos"          {return ACOS;}
"asin"          {return ASIN;}
"tan"           {return TAN;}
"atan"          {return ATAN;}
"^"             {return RAISE;}


[+-]?([0-9]*[.])?[0-9]+  { yylval.iVal = std::stof(yytext); return FLOAT; }
[a-z]* { yylval.sVal = strdup(yytext); return VARNAME; }
[A-Z]* { yylval.sVal = strdup(yytext); return FUNCNAME; }

","             {return SEPERATOR;}

"="             { return EQUALS; }
"+"             { return ADD; }
"-"             { return SUB; }
"*"             { return MULT; }
"/"             { return DIV; }              
"("				{ return LPAREN; }
")"				{ return RPAREN; }
"{"             {return LCURLY;}
"}"             {return RCURLY;}

":"             {return SHORTHAND;}
">"             {return GREATER;}
"<"             {return LESS;}
"=="            {return LOGEQUAL;}
">="            {return GEQUAL;}
"<="            {return LEQUAL;}    

%%
