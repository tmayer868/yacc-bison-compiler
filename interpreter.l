/***
 From here and forward the lex files included have the
 sole purpose of interpreting tokens to send forward to
 bison. In the bison files, further work is done with
 defined grammar rules comprised of the tokens and
 their data values returned here.
***/

%{
#include<iostream>
#include <string>
#include "tree.h"
#include "interpreter.tab.h"
#define YY_DECL extern "C" int yylex()
#include<vector>
%}

/***
 Each rule returns a token identifier which is generated by bison
 and is defined in the interpreter.tab.h file. yylval is a union
 of possible data types defined in the bison file. We convert
 the value of the int or string matches and store it within the
 union structure.
***/
%%

[ \t]           ;

"]"            { return EOL; }
"["             { return BOL;}
"END"         { return EOP; }//end of program
"START"         { return BOP;}
"end"           { return END;}
"while"         {return WHILE;}
"print"         {return PRINT;}
"max"           {return MAX; }
"roots"         {return ROOTS;}

[+-]?([0-9]*[.])?[0-9]+  { yylval.iVal = std::stof(yytext); return FLOAT; }
[a-z]* { yylval.sVal = strdup(yytext); return VARNAME; }

","             {return SEPERATOR;}

"="             { return EQUALS; }
"+"             { return ADD; }
"-"             { return SUB; }
"*"             { return MULT; }
"/"             { return DIV; }              
"("				{ return LPAREN; }
")"				{ return RPAREN; }
"{"             {return LCURLY;}
"}"             {return RCURLY;}

":"             {return SHORTHAND;}
">"             {return GREATER;}
"<"             {return LESS;}
"=="            {return LOGEQUAL;}
">="            {return GEQUAL;}
"<="            {return LEQUAL;}    

%%
